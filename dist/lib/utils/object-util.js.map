{"version":3,"file":"object-util.js","sources":["../../../packages/utils/object-util.ts"],"sourcesContent":["import * as R from 'ramda';\n\ntype Join<K, P> = K extends string | number ?\n    P extends string | number ?\n    `${K}${'' extends P ? '' : '.'}${P}`\n        : never : never;\ntype Prev = [never, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10,\n    11, 12, 13, 14, 15, 16, 17, 18, 19, 20, ...0[]]\ntype Paths<T, D extends number = 5> = [D] extends [never] ? never : T extends Record<string, any> ?\n    { [K in keyof T]-?: K extends string | number ?\n        `${K}` | Join<K, Paths<T[K], Prev[D]>>\n        : never\n    }[keyof T] : ''\ntype Leaves<T, D extends number = 5> = [D] extends [never] ? never : T extends Record<string, any> ?\n    { [K in keyof T]-?: Join<K, Leaves<T[K], Prev[D]>> }[keyof T] : '';\n\n/**\n * 根據路徑設定屬性\n * @param {Object} target 設定屬性的目標\n * @param {String} path 屬性的路徑 => 'aaa.bbb.ccc'\n * @param {Any} value 屬性的新值\n */\nexport function setPropertyByPath<T extends Record<string, any>>(target: T, path: Paths<T>, value: any) {\n    if (!path) {\n        console.warn('path 不可為空值');\n        return;\n    }\n\n    const pathArray: Array<keyof T> = path.split('.');\n    let findTarget = target;\n\n    while (pathArray.length > 1) {\n        // 如果路經中間遇到undefined, 就產生空物件\n        if (findTarget[pathArray[0]] === undefined) {\n            findTarget[pathArray[0]] = {} as any;\n        }\n        findTarget = findTarget[pathArray.shift()!];\n\n        if (!(findTarget instanceof Object)) {\n            console.warn(`屬性 '${pathArray[0]}' 非物件類別`);\n            return;\n        }\n    }\n\n    findTarget[pathArray[0]] = value;\n}\n\n/**\n * 根據路徑取得屬性\n * @param {Object} target 取屬性的目標\n * @param {String} path 屬性的路徑 => 'aaa.bbb.ccc'\n * @return {Any} 取到的屬性值, 若沒取到就是undefined\n */\nexport function getPropertyByPath<T extends Record<string, any>>(target: T, path: Paths<T>): any {\n    const pathArray = path.split('.');\n    let findTarget = target;\n    try {\n        while (pathArray.length > 0) {\n            findTarget = findTarget[pathArray.shift()!];\n        }\n        return findTarget;\n    } catch (e) {\n        // eslint-disable-next-line\n        console.warn('從物件', target, `上取路徑'${path}'失敗`);\n        return undefined;\n    }\n}\n\n/**\n * 檢查物件是否擁有某個key\n * @param obj 物件\n * @param prop key\n * @return {Boolean}\n */\nexport function objHasProperty<X extends Record<string, any>, Y extends PropertyKey>(obj: X, prop: Y): obj is X & Record<Y, unknown> {\n    return Object.hasOwnProperty.call(obj, prop);\n}\n\n/**\n * 檢查是否非空物件，檢查成功會把所有可選屬性都變成必須\n * 但實際上不一定，要注意檢查空值\n * @param obj 物件\n * @return {Boolean}\n */\nexport function dataIsSet<X extends Record<string, any>>(obj: X): obj is X & Required<X> {\n    return Object.keys(obj).length > 0;\n}\n\n/**\n * 檢查是否為兩層或以上的陣列\n *\n * @param obj 物件\n * @return {Boolean}\n */\nexport function isTwoLayArray(array: any[]): array is any[][] {\n    for (const subArray of array.values()) {\n        if (Array.isArray(subArray)) {\n            return true;\n        }\n    }\n    return false;\n}\n\n/**\n * JSON字串轉換成陣列\n * 失敗的話回傳空陣列，注意`不會檢查轉換的結果是否符合泛型`\n * @param jsonString json字串\n */\nexport function jsonArrayCovert<T>(jsonString: string) {\n    let array: T[] = [];\n\n    try {\n        array = JSON.parse(jsonString);\n    } catch (e) {\n        // eslint-disable-next-line\n        console.warn(`jsonArrayCovert => \\`${jsonString}\\` fail`);\n    }\n    return array;\n}\n\n/**\n * 將物件所有屬性設定為zeroValue，\n * 只會轉換 `number`、`string`、`boolean`屬性\n * @param obj 物件\n */\nexport function zeroValueObject<T extends Record<string, any>>(obj: T, needClone = true): T {\n    const newObj = needClone ? R.clone(obj) : obj;\n\n    R.forEachObjIndexed((value, key) => {\n        switch (typeof newObj[key]) {\n            case 'number':\n                (newObj[key] as number) = 0;\n                break;\n            case 'string':\n                (newObj[key] as string) = '';\n                break;\n            case 'boolean':\n                (newObj[key] as boolean) = false;\n                break;\n            case 'object':\n                if (Object.keys(newObj[key]).length) {\n                    newObj[key] = zeroValueObject(newObj[key], false);\n                }\n                break;\n            default:\n                break;\n        }\n    }, newObj);\n\n    return newObj;\n}\n\n/**\n * 測試物件裡所有key的值都是zeroValue\n * 多層物件會一直遞迴找到非 `object` 型態的屬性為止\n * @param obj 物件\n * @param excludeKey 要跳過檢查的key\n */\nexport function checkZeroObject<T extends Record<string, any>>(obj: T, excludeKey: Record<string, boolean> = {}): boolean {\n    let valid = true;\n\n    R.forEachObjIndexed((item, key) => {\n        if (objHasProperty(excludeKey, key) && excludeKey[key]) return;\n\n        if (typeof item === 'object') {\n            if (!checkZeroObject(item)) {\n                valid = false;\n            }\n        } else if (item) {\n            valid = false;\n        }\n    }, obj);\n\n    return valid;\n}"],"names":["R"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;2BAsBiE,QAAW,MAAgB,OAAY;AACpG,MAAI,CAAC,MAAM;AACP,YAAQ,KAAK;AACb;AAAA;AAGJ,QAAM,YAA4B,KAAK,MAAM;AAC7C,MAAI,aAAa;AAEjB,SAAO,UAAU,SAAS,GAAG;AAEzB,QAAI,WAAW,UAAU,QAAQ,QAAW;AACxC,iBAAW,UAAU,MAAM;AAAA;AAE/B,iBAAa,WAAW,UAAU;AAElC,QAAI,wBAAwB,SAAS;AACjC,cAAQ,KAAK,iBAAO,UAAU;AAC9B;AAAA;AAAA;AAIR,aAAW,UAAU,MAAM;AAAA;2BASkC,QAAW,MAAqB;AAC7F,QAAM,YAAY,KAAK,MAAM;AAC7B,MAAI,aAAa;AACjB,MAAI;AACA,WAAO,UAAU,SAAS,GAAG;AACzB,mBAAa,WAAW,UAAU;AAAA;AAEtC,WAAO;AAAA,WACF,GAAP;AAEE,YAAQ,KAAK,sBAAO,QAAQ,4BAAQ;AACpC,WAAO;AAAA;AAAA;wBAUsE,KAAQ,MAAwC;AACjI,SAAO,OAAO,eAAe,KAAK,KAAK;AAAA;mBASc,KAAgC;AACrF,SAAO,OAAO,KAAK,KAAK,SAAS;AAAA;uBASP,OAAgC;AAC1D,aAAW,YAAY,MAAM,UAAU;AACnC,QAAI,MAAM,QAAQ,WAAW;AACzB,aAAO;AAAA;AAAA;AAGf,SAAO;AAAA;yBAQwB,YAAoB;AACnD,MAAI,QAAa;AAEjB,MAAI;AACA,YAAQ,KAAK,MAAM;AAAA,WACd,GAAP;AAEE,YAAQ,KAAK,wBAAwB;AAAA;AAEzC,SAAO;AAAA;yBAQoD,KAAQ,YAAY,MAAS;AACxF,QAAM,SAAS,YAAYA,aAAE,MAAM,OAAO;AAE1C,eAAE,kBAAkB,CAAC,OAAO,QAAQ;AAChC,YAAQ,OAAO,OAAO;AAAA,WACb;AACD,QAAC,OAAO,OAAkB;AAC1B;AAAA,WACC;AACD,QAAC,OAAO,OAAkB;AAC1B;AAAA,WACC;AACD,QAAC,OAAO,OAAmB;AAC3B;AAAA,WACC;AACD,YAAI,OAAO,KAAK,OAAO,MAAM,QAAQ;AACjC,iBAAO,OAAO,gBAAgB,OAAO,MAAM;AAAA;AAE/C;AAAA;AAEA;AAAA;AAAA,KAET;AAEH,SAAO;AAAA;yBASoD,KAAQ,aAAsC,IAAa;AACtH,MAAI,QAAQ;AAEZ,eAAE,kBAAkB,CAAC,MAAM,QAAQ;AAC/B,QAAI,eAAe,YAAY,QAAQ,WAAW;AAAM;AAExD,QAAI,OAAO,SAAS,UAAU;AAC1B,UAAI,CAAC,gBAAgB,OAAO;AACxB,gBAAQ;AAAA;AAAA,eAEL,MAAM;AACb,cAAQ;AAAA;AAAA,KAEb;AAEH,SAAO;AAAA;;;;;;;;;;;"}